# fake-GLV

## GLV 
 It is well known that if the curve is equipped with an efficient endomorphism then there exists a faster algorithm known as [[GLV]](https://www.iacr.org/archive/crypto2001/21390189.pdf). 

**Example 1 :** suppose that $E$ has Complex Multiplication (CM) with discrimant $-D=-3$, i.e. $E$ is of the form $y^2=x^3+b$, with $b \in \mathbb{F}_p$. This is the case of `BN254`, `BLS12-381` and `secp256k1` elliptic curves used in Ethereum. There is an efficient endomorphism $\phi: E \rightarrow E$ defined by $(x,y)\mapsto (\omega x,y)$ (and $\mathcal{O} \mapsto \mathcal{O}$) that acts on $P \in E[r]$ as $\phi(P)=\lambda \cdot P$. Both $\omega$ and $\lambda$ are cube roots of unity in $\mathbb{F}_p$ and $\mathbb{F}_r$ respectively, i.e. $\omega^2+\omega+1 \equiv 0 \pmod p$ and $\lambda^2+\lambda+1 \equiv 0 \pmod r$.

**Example 2 :** suppose that $E$ has Complex Multiplication (CM) with discrimant $-D=-8$, meaning that the endomorphism ring is $\mathbf{Z}[\sqrt{‚àí2}]$. This is the case of the `Bandersnatch` elliptic curves specified in Ethereum Verkle trie. There is an efficient endomorphism $\phi: E \rightarrow E$ whose kernel is generated by a 2-torsion point. The map can be found by looking at 2-isogeneous curves and applying V√©lu's formulas. For Bandersnatch it is defined by $(x,y)\mapsto (u^2\cdot \frac{x^2+wx+t}{x+w},u^3\cdot y\cdot \frac{x^2+2wx+v}{(x+w)^2})$ for some constants $u,v,w,t$ (and $\mathcal{O} \mapsto \mathcal{O}$) that acts on $P \in E[r]$ as $\phi(P)=\lambda \cdot P$ where $\lambda^2+2 \equiv 0 \pmod r$. 

The GLV algorithm starts by decomposing $s$ as $s = s_0 + \lambda s_1$ and then replacing the scalar multiplication $s \cdot P$ by $s_0 \cdot P + s_1 \cdot \phi(P)$. Because $s_0$ and $s_1$ are guaranteed to be $\leq \sqrt{r}$ (see Sec.4 of [[GLV]](https://www.iacr.org/archive/crypto2001/21390189.pdf) and Sec.4 of [[FourQ]](https://eprint.iacr.org/2015/565.pdf) for an optimization trick), we can halve the size of the for loop in the double-and-add algorithm. We can then scan simultaenously the bits of $s_0$ and $s_1$ and apply the [Strauss-Shamir trick](https://crypto.stackexchange.com/questions/99975/strauss-shamir-trick-on-ec-multiplication-by-scalar). This results in a significant speed up but only when an endomorphism is available. For example the left-to-right double-and-add would become:

```
INPUT: s and P ‚àà E(Fp).
OUTPUT: sP.
1. Find s1 and s2 s.t. s = s1 + ùúÜ * s2 mod r 
    1.1 let s1 = (s1_{t‚àí1},..., s1_1, s1_0) 
    1.2 and s2 = = (s2_{t‚àí1},..., s2_1, s2_0)
2. P1 ‚Üê P, P2 ‚Üê ùúô(P) and Q ‚Üê ‚àû.
3. For i from t‚àí1 downto 0 do
    3.1 Q ‚Üê 2Q.
    3.2 If s1_i = 0 and s2_i = 0 then Q ‚Üê Q.
    3.3 If s1_i = 1 and s2_i = 0 then Q ‚Üê Q + P1.
    3.4 If s1_i = 0 and s2_i = 1 then Q ‚Üê Q + P2.
    3.5 If s1_i = 1 and s2_i = 1 then Q ‚Üê Q + P1 + P2.
4. Return(Q).
```

Using the efficient endomorphism in-circuit is also possible (see [[Halo, Sec. 6.2 and Appendix C]](https://eprint.iacr.org/2019/1021.pdf) or [[gnark implementation]](https://github.com/Consensys/gnark/blob/ea53f373f45d2f9ad9cc1639c34359a35f771191/std/algebra/emulated/sw_emulated/point.go#L530) for short Weierstrass curves and [[arkworks]](https://github.com/zhenfeizhang/bandersnatch-glv) and [[gnark]](https://github.com/Consensys/gnark/blob/master/std/algebra/native/twistededwards/scalarmul_glv.go) implementations for twisted Edwards). But one should be careful about some extra checks of the decomposition $s = s_0 + \lambda s_1 \mod r$ (not the SNARK modulus). The integers $s_0, s_1$ can possibly be negative in which case they will be reduced in-circuit modulo the SNARK field and not $r$.
## Fake-GLV
Remember that we are proving that $s\cdot P = Q$ and not computing it. We can "hint" the result $Q$ and check in-circuit that $s\cdot P - Q = \mathcal{O}$. Now, if we can find $u,v \leq \sqrt{r}$ such that $v\cdot s = u \pmod r$ then we can check instead that
$(v\cdot s)\cdot P - v\cdot Q = \mathcal{O}$
which is equivalent to
$u\cdot P - v\cdot Q = \mathcal{O}$
The thing now is that $u$ and $v$ are "small" and we can, similarly to the GLV algorithm, halve the size of the double-and-add loop and apply the Strauss-Shamir trick.

**Solution**: running the half-GCD algorithm (i.e. running GCD half-way) is sufficient to find $u$ and $v$. We can apply the exact same trick for finding the lattice basis as in the GLV paper (Sec. 4). For completeness we recall the algorithm hereafter.
We apply the extended Euclidean algorithm to find the greatest common divisor of $r$ and $s$ (This gcd is 1 since $r$ is prime.) The algorithm produces a sequence of equations
$$w_i \cdot r + v_i \cdot s = u_i$$
for $i = 0, 1, 2, \dots$  where $w_0 = 1, v_0 = 0, u_0 = r, w_1 = 0, v_1 = 1, u_1 = s$, and $u_i \geq 0$ for all $i$. We stop at the index $m$ for which $u_m \geq \sqrt{r}$ and take $u = u_{m+1}$ and $v = -v_{m+1}$.
*Note:* By construction $u$ is guaranteed to be a positive integer but $v$ can be negative, in which case it would be reduced in-circuit modulo the SNARK modulus and not $r$. To circumvent this we return in the hint $u$, $v$ and a $\texttt{b}=1$ if $v$ is negative and $\texttt{b}=0$ otherwise. In-circuit we negate $Q$ instead when $\texttt{b}=1$.

## GLV + Fake-GLV
<img width="799" alt="image" src="https://github.com/user-attachments/assets/d19d7808-109d-4ea9-834e-eb6414c2b3e5">

The idea of Liam to first apply GLV and then the "fake GLV" by doing a half GCD in the number field $\mathbb{K}$ works for curves of j-invariant 0 and 1728. Basically the half GCD in Eisenstein and Gauss ring of integers works the same as in $\mathbb{Z}$. [Here](https://gist.github.com/yelhousni/5d175ba601be3dac86c1c05070861675) is a working example in sagemath for `secp256k1` ($j=0$). However it does not seem to be working for Bandersnatch $\mathbb{K}=\mathbb{Q}[\sqrt{-2}]$ as the geometry is different.
